#!/usr/bin/env python3

import asyncio
import argparse
import hashlib
import hmac
import json
import os
import time
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Union
from urllib.parse import urlencode

import aiohttp
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.stdio import stdio_server
from mcp.types import TextContent, Tool
from pydantic import BaseModel, Field


class BinanceConfig:
    """Configuration for Binance API"""
    BASE_URL = "https://fapi.binance.com"
    
    def __init__(self, api_key: str = "", secret_key: str = ""):
        self.api_key = api_key
        self.secret_key = secret_key


class TickerCache:
    """Cache for 24hr ticker data to avoid repeated API calls"""
    
    def __init__(self, cache_duration_minutes: int = 5):
        self.cache_duration = timedelta(minutes=cache_duration_minutes)
        self.data: List[Dict] = []
        self.last_updated: Optional[datetime] = None
        self.sorted_gainers: List[Dict] = []
        self.sorted_losers: List[Dict] = []
        self.active_symbols: set = set()  # Cache of active symbol names
        self.exchange_info_updated: Optional[datetime] = None
        
    def is_expired(self) -> bool:
        """Check if cache is expired"""
        if self.last_updated is None:
            return True
        return datetime.now() - self.last_updated > self.cache_duration
    
    def is_exchange_info_expired(self) -> bool:
        """Check if exchange info cache is expired (refresh every 30 minutes)"""
        if self.exchange_info_updated is None:
            return True
        return datetime.now() - self.exchange_info_updated > timedelta(minutes=30)
    
    def update_active_symbols(self, exchange_info: Dict):
        """Update list of active symbols from exchangeInfo"""
        try:
            active_symbols = set()
            symbols_data = exchange_info.get('symbols', [])
            
            for symbol_info in symbols_data:
                symbol = symbol_info.get('symbol', '')
                status = symbol_info.get('status', '')
                
                # Only include symbols that are actively trading
                # Exclude: SETTLING (delisted), CLOSE, AUCTION_MATCH, etc.
                if status == 'TRADING':
                    active_symbols.add(symbol)
            
            self.active_symbols = active_symbols
            self.exchange_info_updated = datetime.now()
            
            print(f"âœ… Active symbols updated: {len(active_symbols)} trading symbols")
            
            # Log some examples of excluded symbols for debugging
            all_symbols = {s.get('symbol', '') for s in symbols_data}
            excluded_symbols = all_symbols - active_symbols
            if excluded_symbols:
                excluded_sample = list(excluded_symbols)[:5]
                print(f"   ðŸ“‹ Excluded symbols (sample): {excluded_sample}")
                
        except Exception as e:
            print(f"âŒ Failed to update active symbols: {e}")
            # Keep existing active_symbols if update fails
    
    def update_cache(self, data: List[Dict]):
        """Update cache with new data and sort by price change"""
        self.last_updated = datetime.now()
        
        # Filter out symbols with zero volume, invalid price change, or delisted status
        valid_data = []
        excluded_count = 0
        
        for item in data:
            try:
                symbol = item.get('symbol', '')
                price_change_percent = float(item.get('priceChangePercent', 0))
                volume = float(item.get('volume', 0))
                
                # Check if symbol is actively trading (not delisted/settling)
                is_active = len(self.active_symbols) == 0 or symbol in self.active_symbols
                
                if volume > 0 and is_active:  # Only include symbols with trading volume and active status
                    item['priceChangePercent'] = price_change_percent
                    valid_data.append(item)
                else:
                    excluded_count += 1
                    
            except (ValueError, TypeError):
                excluded_count += 1
                continue
        
        # Store only the filtered data
        self.data = valid_data
        
        # Sort by price change percentage
        self.sorted_gainers = sorted(valid_data, key=lambda x: x['priceChangePercent'], reverse=True)
        self.sorted_losers = sorted(valid_data, key=lambda x: x['priceChangePercent'])
        
        print(f"ðŸ“Š Cache updated: {len(valid_data)} active symbols, {excluded_count} excluded (delisted/no volume)")
    
    def get_top_gainers(self, limit: int = 10) -> List[Dict]:
        """Get top gainers"""
        return self.sorted_gainers[:limit]
    
    def get_top_losers(self, limit: int = 10) -> List[Dict]:
        """Get top losers"""
        return self.sorted_losers[:limit]
    
    def get_symbol_data(self, symbol: str) -> Optional[Dict]:
        """Get data for specific symbol from cache"""
        for item in self.data:
            if item.get('symbol') == symbol.upper():
                return item
        return None


class BinanceClient:
    """Binance Futures API client with improved connectivity"""
    
    def __init__(self, config: BinanceConfig):
        self.config = config
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        # Create session with better connectivity settings
        timeout = aiohttp.ClientTimeout(total=30, connect=10)
        connector = aiohttp.TCPConnector(
            ttl_dns_cache=300,
            use_dns_cache=True,
            limit=100,
            limit_per_host=10,
            enable_cleanup_closed=True
        )
        
        self.session = aiohttp.ClientSession(
            timeout=timeout,
            connector=connector,
            headers={
                'User-Agent': 'binance-mcp-server/1.0.9',
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    def _generate_signature(self, query_string: str) -> str:
        """Generate HMAC SHA256 signature"""
        return hmac.new(
            self.config.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    async def _make_request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        security_type: str = "NONE"
    ) -> Dict[str, Any]:
        """Make API request to Binance"""
        
        if params is None:
            params = {}
        
        url = self.config.BASE_URL + endpoint
        headers = {}
        
        if security_type in ["USER_DATA", "TRADE"]:
            # Add API key to headers
            headers["X-MBX-APIKEY"] = self.config.api_key
            
            # Add timestamp
            params["timestamp"] = int(time.time() * 1000)
            
            # Generate signature
            query_string = urlencode(params)
            signature = self._generate_signature(query_string)
            params["signature"] = signature
        
        try:
            if method == "GET":
                async with self.session.get(url, params=params, headers=headers, ssl=False) as response:
                    if response.status != 200:
                        error_text = await response.text()
                        raise Exception(f"HTTP {response.status}: {error_text}")
                    return await response.json()
            elif method == "POST":
                async with self.session.post(url, data=params, headers=headers, ssl=False) as response:
                    if response.status != 200:
                        error_text = await response.text()
                        raise Exception(f"HTTP {response.status}: {error_text}")
                    return await response.json()
            elif method == "DELETE":
                async with self.session.delete(url, data=params, headers=headers, ssl=False) as response:
                    if response.status != 200:
                        error_text = await response.text()
                        raise Exception(f"HTTP {response.status}: {error_text}")
                    return await response.json()
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
                
        except aiohttp.ClientError as e:
            raise Exception(f"Network error connecting to Binance API: {str(e)}")
        except asyncio.TimeoutError:
            raise Exception("Request timeout - please check your internet connection")
        except Exception as e:
            raise Exception(f"Request failed: {str(e)}")


class BinanceMCPServer:
    """Binance MCP Server implementation"""
    
    def __init__(self, api_key: str = "", secret_key: str = ""):
        self.server = Server("binance-futures-mcp-server")
        self.config = BinanceConfig(api_key, secret_key)
        self.ticker_cache = TickerCache(cache_duration_minutes=5)  # Cache for 5 minutes
        self._background_task = None  # Will be started when server runs
        self._setup_tools()
    
    async def _background_ticker_refresh(self):
        """Background task to refresh ticker data every 5 minutes"""
        print("ðŸ”„ Starting background ticker refresh task...")
        while True:
            try:
                await asyncio.sleep(300)  # Wait 5 minutes
                await self._refresh_ticker_cache()
            except Exception as e:
                print(f"Error refreshing ticker cache: {e}")
                await asyncio.sleep(60)  # Wait 1 minute before retry
    
    def _start_background_task_if_needed(self):
        """Start background task if not already running"""
        if self._background_task is None or self._background_task.done():
            try:
                self._background_task = asyncio.create_task(self._background_ticker_refresh())
                print("âœ… Background ticker refresh task started")
            except RuntimeError:
                # Event loop not running yet, task will be started on first cache access
                print("â³ Event loop not ready, background task will start on first cache access")
    
    async def _ensure_cache_fresh(self):
        """Ensure cache is fresh, refresh if needed, and start background task"""
        # Start background task if needed
        self._start_background_task_if_needed()
        
        # If cache is expired, refresh it immediately
        if self.ticker_cache.is_expired():
            print("ðŸ”„ Cache expired, refreshing immediately...")
            await self._refresh_ticker_cache()
    
    async def _refresh_ticker_cache(self):
        """Refresh the ticker cache with latest data, filtering out delisted tokens"""
        try:
            async with BinanceClient(self.config) as client:
                # Step 1: Update exchange info if expired (every 30 minutes)
                if self.ticker_cache.is_exchange_info_expired():
                    print("ðŸ”„ Refreshing exchange info to filter delisted tokens...")
                    exchange_info = await client._make_request("GET", "/fapi/v1/exchangeInfo")
                    self.ticker_cache.update_active_symbols(exchange_info)
                
                # Step 2: Fetch all 24hr ticker data
                print("ðŸ”„ Fetching 24hr ticker data...")
                result = await client._make_request("GET", "/fapi/v1/ticker/24hr")
                
                # Step 3: Update cache with filtering
                self.ticker_cache.update_cache(result)
                
                active_count = len([item for item in self.ticker_cache.data 
                                  if item.get('symbol') in self.ticker_cache.active_symbols])
                total_count = len(result)
                
                print(f"âœ… Ticker cache refreshed: {active_count}/{total_count} active symbols at {datetime.now()}")
                
        except Exception as e:
            print(f"âŒ Failed to refresh ticker cache: {e}")
            # Don't clear existing cache on failure
    
    def _setup_tools(self):
        """Setup all MCP tools"""
        
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """Handle tools/list requests"""
            return [
                # Account Information Tools
                Tool(
                    name="get_account_info",
                    description="Get futures account information V2",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                ),
                Tool(
                    name="get_balance", 
                    description="Get futures account balance V2",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                ),
                Tool(
                    name="get_position_info",
                    description="Get current position information V2",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_position_mode",
                    description="Get user's position mode (Hedge Mode or One-way Mode)",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                ),
                Tool(
                    name="get_commission_rate",
                    description="Get user's commission rate for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": ["symbol"]
                    }
                ),
                
                # Risk Management Tools
                Tool(
                    name="get_adl_quantile",
                    description="Get position ADL quantile estimation",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_leverage_brackets",
                    description="Get notional and leverage brackets",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_force_orders",
                    description="Get user's force orders",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "auto_close_type": {"type": "string", "description": "Optional filter by auto-close type"},
                            "start_time": {"type": "integer", "description": "Optional start time in ms"},
                            "end_time": {"type": "integer", "description": "Optional end time in ms"},
                            "limit": {"type": "integer", "description": "Maximum number of orders to return (default 50)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_position_margin_history",
                    description="Get position margin modification history",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "margin_type": {"type": "integer", "description": "1 for add position margin, 2 for reduce position margin"},
                            "limit": {"type": "integer", "description": "Number of entries to return"}
                        },
                        "required": ["symbol", "margin_type", "limit"]
                    }
                ),

                # Order Management Tools
                Tool(
                    name="place_order",
                    description="Place a futures order of any type (MARKET, LIMIT, STOP, STOP_MARKET, TRAILING_STOP_MARKET, etc)",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "side": {"type": "string", "description": "Order side ('BUY' or 'SELL')"},
                            "type": {"type": "string", "description": "Order type ('MARKET', 'LIMIT', 'STOP', 'STOP_MARKET', 'TRAILING_STOP_MARKET', etc)"},
                            "order_type": {"type": "string", "description": "Alternative parameter name for 'type' (for backward compatibility)"},
                            "quantity": {"type": "number", "description": "Order quantity"},
                            "price": {"type": "number", "description": "Order price (for LIMIT orders)"},
                            "stopPrice": {"type": "number", "description": "Stop price (for STOP orders)"},
                            "timeInForce": {"type": "string", "description": "Time in force (GTC, IOC, FOK)"},
                            "positionSide": {"type": "string", "description": "Position side ('BOTH', 'LONG', 'SHORT')"},
                            "reduceOnly": {"type": "string", "description": "Reduce only flag ('true' or 'false')"},
                            "newClientOrderId": {"type": "string", "description": "Custom order ID"},
                            "closePosition": {"type": "string", "description": "Close position flag ('true' or 'false')"},
                            "activationPrice": {"type": "number", "description": "Activation price (for TRAILING_STOP_MARKET)"},
                            "callbackRate": {"type": "number", "description": "Callback rate (for TRAILING_STOP_MARKET)"},
                            "workingType": {"type": "string", "description": "Working type (MARK_PRICE, CONTRACT_PRICE)"},
                            "priceProtect": {"type": "string", "description": "Price protection flag ('TRUE' or 'FALSE')"},
                            "newOrderRespType": {"type": "string", "description": "Response type ('ACK', 'RESULT')"},
                            "recvWindow": {"type": "integer", "description": "Receive window"},
                            "timestamp": {"type": "integer", "description": "Timestamp"},
                            "quantity_precision": {"type": "integer", "description": "Quantity precision for validation"},
                            "price_precision": {"type": "integer", "description": "Price precision for validation"}
                        },
                        "required": ["symbol", "side"],
                        "anyOf": [
                            {"required": ["type"]},
                            {"required": ["order_type"]}
                        ]
                    }
                ),
                Tool(
                    name="place_multiple_orders",
                    description="Place multiple orders at once",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "orders": {
                                "type": "array", 
                                "description": "List of order parameters",
                                "items": {"type": "object"}
                            },
                            "quantity_precision": {"type": "integer", "description": "Quantity precision for validation"},
                            "price_precision": {"type": "integer", "description": "Price precision for validation"}
                        },
                        "required": ["orders"]
                    }
                ),
                Tool(
                    name="cancel_order",
                    description="Cancel an active order",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id": {"type": "integer", "description": "Order ID to cancel"}
                        },
                        "required": ["symbol", "order_id"]
                    }
                ),
                Tool(
                    name="cancel_multiple_orders",
                    description="Cancel multiple orders",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id_list": {
                                "type": "array", 
                                "description": "List of order IDs to cancel (up to 10 orders per batch)",
                                "items": {"type": "integer"}
                            }
                        },
                        "required": ["symbol", "order_id_list"]
                    }
                ),
                Tool(
                    name="cancel_all_orders",
                    description="Cancel all open orders for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="auto_cancel_all_orders",
                    description="Set up auto-cancellation of all orders after countdown",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "countdown_time": {"type": "integer", "description": "Countdown time in milliseconds"}
                        },
                        "required": ["symbol", "countdown_time"]
                    }
                ),

                # Order Query Tools
                Tool(
                    name="get_open_order",
                    description="Query current open order by order id",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id": {"type": "integer", "description": "Order ID to query"}
                        },
                        "required": ["symbol", "order_id"]
                    }
                ),
                Tool(
                    name="get_open_orders",
                    description="Get all open futures orders for a specific symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="get_all_orders",
                    description="Get all account orders",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id": {"type": "integer", "description": "Optional order ID to start from"},
                            "start_time": {"type": "integer", "description": "Optional start time in ms"},
                            "end_time": {"type": "integer", "description": "Optional end time in ms"},
                            "limit": {"type": "integer", "description": "Maximum number of orders to return (default 500)"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="query_order",
                    description="Query a specific order's status",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id": {"type": "integer", "description": "Order ID to query"}
                        },
                        "required": ["symbol", "order_id"]
                    }
                ),
                Tool(
                    name="close_position",
                    description="Close current position for a symbol (market order to close all or part of position)",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "position_side": {"type": "string", "description": "Position side to close ('BOTH', 'LONG', 'SHORT'). Default 'BOTH' for One-way mode"},
                            "quantity": {"type": "number", "description": "Quantity to close (optional, if not provided will close entire position)"},
                            "close_all": {"type": "boolean", "description": "If true, closes entire position using closePosition=true parameter"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="modify_order",
                    description="Modify an existing order (price, quantity, etc.)",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "order_id": {"type": "integer", "description": "Order ID to modify"},
                            "side": {"type": "string", "description": "Order side ('BUY' or 'SELL')"},
                            "quantity": {"type": "number", "description": "New order quantity"},
                            "price": {"type": "number", "description": "New order price"},
                            "priceMatch": {"type": "string", "description": "Price match mode (OPPONENT, OPPONENT_5, OPPONENT_10, OPPONENT_20, QUEUE, QUEUE_5, QUEUE_10, QUEUE_20)"}
                        },
                        "required": ["symbol", "order_id", "side", "quantity", "price"]
                    }
                ),
                Tool(
                    name="add_tp_sl_to_position",
                    description="Add Take Profit and/or Stop Loss orders to existing position",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "position_side": {"type": "string", "description": "Position side ('BOTH', 'LONG', 'SHORT'). Default 'BOTH' for One-way mode"},
                            "take_profit_price": {"type": "number", "description": "Take profit price (optional)"},
                            "stop_loss_price": {"type": "number", "description": "Stop loss price (optional)"},
                            "quantity": {"type": "number", "description": "Quantity for TP/SL orders (optional, defaults to position size)"},
                            "tp_order_type": {"type": "string", "description": "Take profit order type ('LIMIT', 'TAKE_PROFIT_MARKET'). Default 'TAKE_PROFIT_MARKET'"},
                            "sl_order_type": {"type": "string", "description": "Stop loss order type ('STOP_MARKET', 'STOP'). Default 'STOP_MARKET'"},
                            "time_in_force": {"type": "string", "description": "Time in force for LIMIT TP orders (GTC, IOC, FOK). Default 'GTC'"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="place_bracket_order",
                    description="Place a position with automatic Take Profit and Stop Loss orders",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "side": {"type": "string", "description": "Order side ('BUY' or 'SELL')"},
                            "quantity": {"type": "number", "description": "Order quantity"},
                            "entry_price": {"type": "number", "description": "Entry price (for LIMIT entry order, optional for MARKET)"},
                            "take_profit_price": {"type": "number", "description": "Take profit price"},
                            "stop_loss_price": {"type": "number", "description": "Stop loss price"},
                            "entry_order_type": {"type": "string", "description": "Entry order type ('MARKET', 'LIMIT'). Default 'MARKET'"},
                            "positionSide": {"type": "string", "description": "Position side ('BOTH', 'LONG', 'SHORT')"},
                            "timeInForce": {"type": "string", "description": "Time in force for LIMIT orders (GTC, IOC, FOK). Default 'GTC'"}
                        },
                        "required": ["symbol", "side", "quantity", "take_profit_price", "stop_loss_price"]
                    }
                ),

                # Trading Configuration Tools
                Tool(
                    name="change_leverage",
                    description="Change initial leverage for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "leverage": {"type": "integer", "description": "Target initial leverage (1-125)"}
                        },
                        "required": ["symbol", "leverage"]
                    }
                ),
                Tool(
                    name="change_margin_type",
                    description="Change margin type between isolated and cross",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "margin_type": {"type": "string", "description": "'ISOLATED' or 'CROSSED'"}
                        },
                        "required": ["symbol", "margin_type"]
                    }
                ),
                Tool(
                    name="change_position_mode",
                    description="Change position mode between Hedge Mode and One-way Mode",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "dual_side": {"type": "boolean", "description": "\"true\" for Hedge Mode, \"false\" for One-way Mode"}
                        },
                        "required": ["dual_side"]
                    }
                ),
                Tool(
                    name="modify_position_margin",
                    description="Modify isolated position margin",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "amount": {"type": "number", "description": "Amount to modify"},
                            "position_side": {"type": "string", "description": "Position side ('BOTH', 'LONG', or 'SHORT')"},
                            "margin_type": {"type": "integer", "description": "1 for add position margin, 2 for reduce position margin"}
                        },
                        "required": ["symbol", "amount", "position_side", "margin_type"]
                    }
                ),

                # Market Data Tools
                Tool(
                    name="get_exchange_info",
                    description="Get exchange trading rules and symbol information",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol (optional)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_book_ticker",
                    description="Get best price/qty on the order book for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_price_ticker",
                    description="Get latest price for a symbol", 
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_24hr_ticker",
                    description="Get 24hr ticker price change statistics",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol (optional, if not provided returns all symbols)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_top_gainers_losers",
                    description="Get top gainers and losers from cached 24hr ticker data (much faster than fetching individual symbols)",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "type": {"type": "string", "description": "Type to get: 'gainers', 'losers', or 'both' (default: 'both')"},
                            "limit": {"type": "integer", "description": "Number of top results to return (default: 10, max: 200)"},
                            "min_volume": {"type": "number", "description": "Minimum 24hr volume filter (optional)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_market_overview",
                    description="Get overall market statistics and top movers from cached data",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "include_top_movers": {"type": "boolean", "description": "Include top 5 gainers and losers (default: true)"},
                            "volume_threshold": {"type": "number", "description": "Minimum volume for market overview calculations (optional)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_order_book",
                    description="Get order book for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "limit": {"type": "integer", "description": "Number of bids/asks (5,10,20,50,100,500,1000)"}
                        },
                        "required": ["symbol", "limit"]
                    }
                ),
                Tool(
                    name="get_klines",
                    description="Get kline/candlestick data for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "interval": {"type": "string", "description": "Kline interval"},
                            "start_time": {"type": "integer", "description": "Start timestamp in ms"},
                            "end_time": {"type": "integer", "description": "End timestamp in ms"},
                            "limit": {"type": "integer", "description": "Number of klines (max 1500)"}
                        },
                        "required": ["symbol", "interval"]
                    }
                ),
                Tool(
                    name="get_mark_price",
                    description="Get mark price and funding rate for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_aggregate_trades",
                    description="Get compressed, aggregate market trades",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "from_id": {"type": "integer", "description": "ID to get trades from"},
                            "start_time": {"type": "integer", "description": "Start timestamp in ms"},
                            "end_time": {"type": "integer", "description": "End timestamp in ms"},
                            "limit": {"type": "integer", "description": "Number of trades (max 1000)"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="get_funding_rate_history",
                    description="Get funding rate history for a symbol",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "start_time": {"type": "integer", "description": "Start timestamp in ms"},
                            "end_time": {"type": "integer", "description": "End timestamp in ms"},
                            "limit": {"type": "integer", "description": "Number of entries (max 1000)"}
                        },
                        "required": []
                    }
                ),
                Tool(
                    name="get_taker_buy_sell_volume",
                    description="Get taker buy/sell volume ratio statistics",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "period": {"type": "string", "description": "Period for the data (5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d)"},
                            "start_time": {"type": "integer", "description": "Start timestamp in ms"},
                            "end_time": {"type": "integer", "description": "End timestamp in ms"},
                            "limit": {"type": "integer", "description": "Number of entries (max 500, default 30)"}
                        },
                        "required": ["symbol", "period"]
                    }
                ),

                # Trading History Tools
                Tool(
                    name="get_account_trades",
                    description="Get account trade list",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "start_time": {"type": "integer", "description": "Optional start time in ms"},
                            "end_time": {"type": "integer", "description": "Optional end time in ms"},
                            "from_id": {"type": "integer", "description": "Optional trade ID to fetch from"},
                            "limit": {"type": "integer", "description": "Maximum number of trades to return (default 500)"}
                        },
                        "required": ["symbol"]
                    }
                ),
                Tool(
                    name="get_income_history",
                    description="Get income history",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "symbol": {"type": "string", "description": "Trading pair symbol"},
                            "income_type": {"type": "string", "description": "Optional income type filter"},
                            "start_time": {"type": "integer", "description": "Optional start time in ms"},
                            "end_time": {"type": "integer", "description": "Optional end time in ms"},
                            "limit": {"type": "integer", "description": "Maximum number of records to return (default 100)"}
                        },
                        "required": []
                    }
                )
            ]
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
            """Handle tool calls"""
            
            # Check if API credentials are configured for authenticated endpoints
            unauthenticated_tools = [
                "get_exchange_info", "get_price_ticker", "get_24hr_ticker", "get_book_ticker", 
                "get_order_book", "get_klines", "get_mark_price", 
                "get_aggregate_trades", "get_funding_rate_history", "get_taker_buy_sell_volume",
                "get_top_gainers_losers", "get_market_overview"
            ]
            
            if not self.config.api_key or not self.config.secret_key:
                if name not in unauthenticated_tools:
                    return [TextContent(
                        type="text",
                        text="Error: API credentials not configured. Please provide valid API key and secret key."
                    )]
            
            try:
                async with BinanceClient(self.config) as client:
                    
                    # Account Information Tools
                    if name == "get_account_info":
                        result = await client._make_request("GET", "/fapi/v2/account", security_type="USER_DATA")
                    elif name == "get_balance":
                        result = await client._make_request("GET", "/fapi/v2/balance", security_type="USER_DATA")
                    elif name == "get_position_info":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v2/positionRisk", params, "USER_DATA")
                    elif name == "get_position_mode":
                        result = await client._make_request("GET", "/fapi/v1/positionSide/dual", security_type="USER_DATA")
                    elif name == "get_commission_rate":
                        params = {"symbol": arguments["symbol"]}
                        result = await client._make_request("GET", "/fapi/v1/commissionRate", params, "USER_DATA")
                    
                    # Risk Management Tools
                    elif name == "get_adl_quantile":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/adlQuantile", params, "USER_DATA")
                    elif name == "get_leverage_brackets":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/leverageBracket", params, "USER_DATA")
                    elif name == "get_force_orders":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/forceOrders", params, "USER_DATA")
                    elif name == "get_position_margin_history":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/positionMargin/history", params, "USER_DATA")
                    
                    # Order Management Tools
                    elif name == "place_order":
                        # Filter out precision parameters and pass through all other parameters directly
                        params = {k: v for k, v in arguments.items() if v is not None and k not in ["quantity_precision", "price_precision"]}
                        
                        # Handle backward compatibility for order_type parameter
                        if "order_type" in params:
                            params["type"] = params.pop("order_type")
                        
                        # Check if type parameter is present
                        if "type" not in params:
                            raise ValueError("Missing required parameter 'type'. Please specify the order type (e.g., 'MARKET', 'LIMIT', 'STOP', etc.)")
                        
                        # Validate mandatory parameters based on order type
                        order_type = params.get("type")
                        if order_type == "LIMIT":
                            required_params = ["timeInForce", "quantity", "price"]
                            missing = [p for p in required_params if p not in params]
                            if missing:
                                raise ValueError(f"LIMIT order missing required parameters: {missing}")
                        elif order_type == "MARKET":
                            if "quantity" not in params:
                                raise ValueError("MARKET order missing required parameter: quantity")
                        elif order_type in ["STOP", "TAKE_PROFIT"]:
                            required_params = ["quantity", "price", "stopPrice"]
                            missing = [p for p in required_params if p not in params]
                            if missing:
                                raise ValueError(f"{order_type} order missing required parameters: {missing}")
                        elif order_type in ["STOP_MARKET", "TAKE_PROFIT_MARKET"]:
                            if "stopPrice" not in params:
                                raise ValueError(f"{order_type} order missing required parameter: stopPrice")
                        elif order_type == "TRAILING_STOP_MARKET":
                            if "callbackRate" not in params:
                                raise ValueError("TRAILING_STOP_MARKET order missing required parameter: callbackRate")
                        
                        result = await client._make_request("POST", "/fapi/v1/order", params, "TRADE")
                    elif name == "place_multiple_orders":
                        # This requires special handling for batch orders
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("POST", "/fapi/v1/batchOrders", params, "TRADE")
                    elif name == "cancel_order":
                        params = {"symbol": arguments["symbol"], "orderId": arguments["order_id"]}
                        result = await client._make_request("DELETE", "/fapi/v1/order", params, "TRADE")
                    elif name == "cancel_multiple_orders":
                        params = {
                            "symbol": arguments["symbol"],
                            "orderIdList": arguments["order_id_list"]
                        }
                        result = await client._make_request("DELETE", "/fapi/v1/batchOrders", params, "TRADE")
                    elif name == "cancel_all_orders":
                        params = {"symbol": arguments["symbol"]}
                        result = await client._make_request("DELETE", "/fapi/v1/allOpenOrders", params, "TRADE")
                    elif name == "auto_cancel_all_orders":
                        params = {
                            "symbol": arguments["symbol"],
                            "countdownTime": arguments["countdown_time"]
                        }
                        result = await client._make_request("POST", "/fapi/v1/countdownCancelAll", params, "TRADE")
                    
                    # Order Query Tools
                    elif name == "get_open_order":
                        params = {"symbol": arguments["symbol"], "orderId": arguments["order_id"]}
                        result = await client._make_request("GET", "/fapi/v1/openOrder", params, "USER_DATA")
                    elif name == "get_open_orders":
                        params = {"symbol": arguments["symbol"]}
                        result = await client._make_request("GET", "/fapi/v1/openOrders", params, "USER_DATA")
                    elif name == "get_all_orders":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/allOrders", params, "USER_DATA")
                    elif name == "query_order":
                        params = {"symbol": arguments["symbol"], "orderId": arguments["order_id"]}
                        result = await client._make_request("GET", "/fapi/v1/order", params, "USER_DATA")
                    elif name == "close_position":
                        # Handle position closing
                        symbol = arguments["symbol"]
                        position_side = arguments.get("position_side", "BOTH")
                        quantity = arguments.get("quantity")
                        close_all = arguments.get("close_all", False)
                        
                        # First, get current position to determine the side and quantity to close
                        position_params = {"symbol": symbol}
                        positions = await client._make_request("GET", "/fapi/v2/positionRisk", position_params, "USER_DATA")
                        
                        # Find the position to close
                        position_to_close = None
                        for pos in positions:
                            if pos["symbol"] == symbol and float(pos["positionAmt"]) != 0:
                                if position_side == "BOTH" or pos["positionSide"] == position_side:
                                    position_to_close = pos
                                    break
                        
                        if not position_to_close:
                            raise ValueError(f"No open position found for {symbol} with position side {position_side}")
                        
                        position_amt = float(position_to_close["positionAmt"])
                        current_position_side = position_to_close["positionSide"]
                        
                        # Determine order side (opposite of position)
                        if position_amt > 0:  # Long position
                            order_side = "SELL"
                        else:  # Short position
                            order_side = "BUY"
                            position_amt = abs(position_amt)  # Make positive for order quantity
                        
                        # Determine quantity to close
                        if close_all:
                            # Use closePosition parameter to close entire position
                            order_params = {
                                "symbol": symbol,
                                "side": order_side,
                                "type": "MARKET",
                                "closePosition": "true"
                            }
                            if current_position_side != "BOTH":
                                order_params["positionSide"] = current_position_side
                        else:
                            # Close specific quantity or entire position
                            close_quantity = quantity if quantity else position_amt
                            order_params = {
                                "symbol": symbol,
                                "side": order_side,
                                "type": "MARKET",
                                "quantity": close_quantity,
                                "reduceOnly": "true"
                            }
                            if current_position_side != "BOTH":
                                order_params["positionSide"] = current_position_side
                        
                        result = await client._make_request("POST", "/fapi/v1/order", order_params, "TRADE")
                    elif name == "modify_order":
                        # Modify existing order
                        params = {
                            "symbol": arguments["symbol"],
                            "orderId": arguments["order_id"],
                            "side": arguments["side"],
                            "quantity": arguments["quantity"],
                            "price": arguments["price"]
                        }
                        if "priceMatch" in arguments:
                            params["priceMatch"] = arguments["priceMatch"]
                        result = await client._make_request("PUT", "/fapi/v1/order", params, "TRADE")
                    elif name == "add_tp_sl_to_position":
                        # Add TP/SL to existing position
                        symbol = arguments["symbol"]
                        position_side = arguments.get("position_side", "BOTH")
                        take_profit_price = arguments.get("take_profit_price")
                        stop_loss_price = arguments.get("stop_loss_price")
                        quantity = arguments.get("quantity")
                        tp_order_type = arguments.get("tp_order_type", "TAKE_PROFIT_MARKET")
                        sl_order_type = arguments.get("sl_order_type", "STOP_MARKET")
                        time_in_force = arguments.get("time_in_force", "GTC")
                        
                        if not take_profit_price and not stop_loss_price:
                            raise ValueError("At least one of take_profit_price or stop_loss_price must be provided")
                        
                        # Get current position to determine side and quantity
                        position_params = {"symbol": symbol}
                        positions = await client._make_request("GET", "/fapi/v2/positionRisk", position_params, "USER_DATA")
                        
                        position_to_hedge = None
                        for pos in positions:
                            if pos["symbol"] == symbol and float(pos["positionAmt"]) != 0:
                                if position_side == "BOTH" or pos["positionSide"] == position_side:
                                    position_to_hedge = pos
                                    break
                        
                        if not position_to_hedge:
                            raise ValueError(f"No open position found for {symbol} with position side {position_side}")
                        
                        position_amt = float(position_to_hedge["positionAmt"])
                        current_position_side = position_to_hedge["positionSide"]
                        
                        # Determine order side (opposite of position)
                        if position_amt > 0:  # Long position
                            tp_sl_side = "SELL"
                        else:  # Short position  
                            tp_sl_side = "BUY"
                            position_amt = abs(position_amt)
                        
                        order_quantity = quantity if quantity else position_amt
                        results = []
                        
                        # Place Take Profit order
                        if take_profit_price:
                            tp_params = {
                                "symbol": symbol,
                                "side": tp_sl_side,
                                "type": tp_order_type,
                                "quantity": order_quantity,
                                "reduceOnly": "true"
                            }
                            
                            if current_position_side != "BOTH":
                                tp_params["positionSide"] = current_position_side
                            
                            if tp_order_type == "TAKE_PROFIT_MARKET":
                                tp_params["stopPrice"] = take_profit_price
                            else:  # LIMIT
                                tp_params["price"] = take_profit_price
                                tp_params["timeInForce"] = time_in_force
                            
                            tp_result = await client._make_request("POST", "/fapi/v1/order", tp_params, "TRADE")
                            results.append({"type": "take_profit", "result": tp_result})
                        
                        # Place Stop Loss order
                        if stop_loss_price:
                            sl_params = {
                                "symbol": symbol,
                                "side": tp_sl_side,
                                "type": sl_order_type,
                                "quantity": order_quantity,
                                "reduceOnly": "true"
                            }
                            
                            if current_position_side != "BOTH":
                                sl_params["positionSide"] = current_position_side
                            
                            if sl_order_type == "STOP_MARKET":
                                sl_params["stopPrice"] = stop_loss_price
                            else:  # STOP
                                sl_params["price"] = stop_loss_price
                                sl_params["stopPrice"] = stop_loss_price
                                sl_params["timeInForce"] = time_in_force
                            
                            sl_result = await client._make_request("POST", "/fapi/v1/order", sl_params, "TRADE")
                            results.append({"type": "stop_loss", "result": sl_result})
                        
                        result = results
                    elif name == "place_bracket_order":
                        # Place entry order with TP/SL
                        symbol = arguments["symbol"]
                        side = arguments["side"]
                        quantity = arguments["quantity"]
                        entry_price = arguments.get("entry_price")
                        take_profit_price = arguments["take_profit_price"]
                        stop_loss_price = arguments["stop_loss_price"]
                        entry_order_type = arguments.get("entry_order_type", "MARKET")
                        position_side = arguments.get("positionSide", "BOTH")
                        time_in_force = arguments.get("timeInForce", "GTC")
                        
                        results = []
                        
                        # Place entry order
                        entry_params = {
                            "symbol": symbol,
                            "side": side,
                            "type": entry_order_type,
                            "quantity": quantity
                        }
                        
                        if position_side != "BOTH":
                            entry_params["positionSide"] = position_side
                        
                        if entry_order_type == "LIMIT":
                            if not entry_price:
                                raise ValueError("entry_price is required for LIMIT orders")
                            entry_params["price"] = entry_price
                            entry_params["timeInForce"] = time_in_force
                        
                        entry_result = await client._make_request("POST", "/fapi/v1/order", entry_params, "TRADE")
                        results.append({"type": "entry", "result": entry_result})
                        
                        # Determine TP/SL side (opposite of entry)
                        tp_sl_side = "SELL" if side == "BUY" else "BUY"
                        
                        # Place Take Profit order
                        tp_params = {
                            "symbol": symbol,
                            "side": tp_sl_side,
                            "type": "TAKE_PROFIT_MARKET",
                            "quantity": quantity,
                            "stopPrice": take_profit_price,
                            "reduceOnly": "true"
                        }
                        if position_side != "BOTH":
                            tp_params["positionSide"] = position_side
                        
                        tp_result = await client._make_request("POST", "/fapi/v1/order", tp_params, "TRADE")
                        results.append({"type": "take_profit", "result": tp_result})
                        
                        # Place Stop Loss order
                        sl_params = {
                            "symbol": symbol,
                            "side": tp_sl_side,
                            "type": "STOP_MARKET",
                            "quantity": quantity,
                            "stopPrice": stop_loss_price,
                            "reduceOnly": "true"
                        }
                        if position_side != "BOTH":
                            sl_params["positionSide"] = position_side
                        
                        sl_result = await client._make_request("POST", "/fapi/v1/order", sl_params, "TRADE")
                        results.append({"type": "stop_loss", "result": sl_result})
                        
                        result = results
                    
                    # Trading Configuration Tools
                    elif name == "change_leverage":
                        params = {
                            "symbol": arguments["symbol"],
                            "leverage": arguments["leverage"]
                        }
                        result = await client._make_request("POST", "/fapi/v1/leverage", params, "TRADE")
                    elif name == "change_margin_type":
                        params = {
                            "symbol": arguments["symbol"],
                            "marginType": arguments["margin_type"]
                        }
                        result = await client._make_request("POST", "/fapi/v1/marginType", params, "TRADE")
                    elif name == "change_position_mode":
                        params = {"dualSidePosition": arguments["dual_side"]}
                        result = await client._make_request("POST", "/fapi/v1/positionSide/dual", params, "TRADE")
                    elif name == "modify_position_margin":
                        params = {
                            "symbol": arguments["symbol"],
                            "positionSide": arguments["position_side"],
                            "amount": arguments["amount"],
                            "type": arguments["margin_type"]
                        }
                        result = await client._make_request("POST", "/fapi/v1/positionMargin", params, "TRADE")
                    
                    # Market Data Tools
                    elif name == "get_exchange_info":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/exchangeInfo", params)
                    elif name == "get_book_ticker":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/ticker/bookTicker", params)
                    elif name == "get_price_ticker":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/ticker/price", params)
                    elif name == "get_24hr_ticker":
                        symbol = arguments.get("symbol")
                        if symbol:
                            # Check cache first for specific symbol
                            await self._ensure_cache_fresh()
                            cached_data = self.ticker_cache.get_symbol_data(symbol)
                            if cached_data:
                                result = cached_data
                            else:
                                # Symbol not in cache, fetch from API
                                params = {"symbol": symbol}
                                result = await client._make_request("GET", "/fapi/v1/ticker/24hr", params)
                        else:
                            # No symbol specified, ensure cache is fresh and return all data
                            await self._ensure_cache_fresh()
                            result = self.ticker_cache.data
                    elif name == "get_top_gainers_losers":
                        # Ensure cache is fresh
                        await self._ensure_cache_fresh()
                        
                        request_type = arguments.get("type", "both").lower()
                        limit = min(arguments.get("limit", 10), 200)  # Max 200
                        min_volume = arguments.get("min_volume", 0)
                        
                        result = {}
                        
                        if request_type in ["gainers", "both"]:
                            gainers = self.ticker_cache.get_top_gainers(limit)
                            if min_volume > 0:
                                gainers = [g for g in gainers if float(g.get('volume', 0)) >= min_volume]
                            result["gainers"] = gainers[:limit]
                        
                        if request_type in ["losers", "both"]:
                            losers = self.ticker_cache.get_top_losers(limit)
                            if min_volume > 0:
                                losers = [l for l in losers if float(l.get('volume', 0)) >= min_volume]
                            result["losers"] = losers[:limit]
                        
                        # Add metadata
                        result["metadata"] = {
                            "last_updated": self.ticker_cache.last_updated.isoformat() if self.ticker_cache.last_updated else None,
                            "total_symbols": len(self.ticker_cache.data),
                            "filter_applied": {"min_volume": min_volume} if min_volume > 0 else None
                        }
                    elif name == "get_market_overview":
                        # Ensure cache is fresh
                        await self._ensure_cache_fresh()
                        
                        include_top_movers = arguments.get("include_top_movers", True)
                        volume_threshold = arguments.get("volume_threshold", 0)
                        
                        # Filter data by volume threshold
                        filtered_data = self.ticker_cache.data
                        if volume_threshold > 0:
                            filtered_data = [d for d in self.ticker_cache.data if float(d.get('volume', 0)) >= volume_threshold]
                        
                        # Calculate market statistics
                        total_symbols = len(filtered_data)
                        gainers_count = len([d for d in filtered_data if float(d.get('priceChangePercent', 0)) > 0])
                        losers_count = len([d for d in filtered_data if float(d.get('priceChangePercent', 0)) < 0])
                        unchanged_count = total_symbols - gainers_count - losers_count
                        
                        # Calculate total market volume
                        total_volume = sum(float(d.get('volume', 0)) for d in filtered_data)
                        
                        result = {
                            "market_summary": {
                                "total_symbols": total_symbols,
                                "gainers": gainers_count,
                                "losers": losers_count,
                                "unchanged": unchanged_count,
                                "total_24h_volume": total_volume,
                                "last_updated": self.ticker_cache.last_updated.isoformat() if self.ticker_cache.last_updated else None
                            }
                        }
                        
                        if include_top_movers:
                            top_gainers = self.ticker_cache.get_top_gainers(5)
                            top_losers = self.ticker_cache.get_top_losers(5)
                            
                            if volume_threshold > 0:
                                top_gainers = [g for g in top_gainers if float(g.get('volume', 0)) >= volume_threshold][:5]
                                top_losers = [l for l in top_losers if float(l.get('volume', 0)) >= volume_threshold][:5]
                            
                            result["top_movers"] = {
                                "top_gainers": top_gainers,
                                "top_losers": top_losers
                            }
                    elif name == "get_order_book":
                        params = {
                            "symbol": arguments["symbol"],
                            "limit": arguments["limit"]
                        }
                        result = await client._make_request("GET", "/fapi/v1/depth", params)
                    elif name == "get_klines":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/klines", params)
                    elif name == "get_mark_price":
                        params = {}
                        if "symbol" in arguments:
                            params["symbol"] = arguments["symbol"]
                        result = await client._make_request("GET", "/fapi/v1/premiumIndex", params)
                    elif name == "get_aggregate_trades":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/aggTrades", params)
                    elif name == "get_funding_rate_history":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/fundingRate", params)
                    elif name == "get_taker_buy_sell_volume":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/futures/data/takerlongshortRatio", params)
                    
                    # Trading History Tools
                    elif name == "get_account_trades":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/userTrades", params, "USER_DATA")
                    elif name == "get_income_history":
                        params = {k: v for k, v in arguments.items() if v is not None}
                        result = await client._make_request("GET", "/fapi/v1/income", params, "USER_DATA")
                    
                    else:
                        raise ValueError(f"Unknown tool: {name}")
                    
                    return [TextContent(
                        type="text",
                        text=json.dumps(result, indent=2)
                    )]
                    
            except Exception as e:
                return [TextContent(
                    type="text",
                    text=f"Error: {str(e)}"
                )]


async def main():
    import argparse
    import os
    
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Binance Futures MCP Server")
    parser.add_argument("--binance-api-key", 
                       help="Binance API key", 
                       default=os.getenv("BINANCE_API_KEY", ""))
    parser.add_argument("--binance-secret-key", 
                       help="Binance secret key", 
                       default=os.getenv("BINANCE_SECRET_KEY", ""))
    
    args = parser.parse_args()
    
    # Initialize server with credentials
    server_instance = BinanceMCPServer(args.binance_api_key, args.binance_secret_key)
    
    # Run server using stdio
    async with stdio_server() as (read_stream, write_stream):
        await server_instance.server.run(
            read_stream, 
            write_stream, 
            InitializationOptions(
                server_name="binance-futures-mcp-server",
                server_version="1.0.9",
                capabilities={
                    "tools": {}
                }
            )
        )


if __name__ == "__main__":
    asyncio.run(main())
